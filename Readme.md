
Приложение Sweater - Аналог твиттера
***

[канал let's code](https://www.youtube.com/channel/UC1g3kT0ZcSXt4_ZyJOshKJQ)
***

#### Этапы

* подготовка
    * идем на spring.io
    * в гайдах ищем MVC
    * создаём проект maven
    
          
* урок 1 (Hello, World)
    * pom.xml
        * указываем используемую версию java
        * секцию **parent** для spring boot
        * зависимости:
            * thymeleaf (шаблонизатор)
            * starter-web
            * dev-tools (для удобного перезапуска приложения)
            * тестирование
        * а также плагин для сборки
    * добавляем GreetingController
    * а также класс запуска приложения ServingWebContentApplication
    * и страницу greeting.html, которая просто отображает имя, переданное через get-параметр name


* урок 1 (Hello, World). часть 2. замена thymeleaf на mustache (шаблонизатор попроще)
    * изменяем dependency
    * greeting.html на greeting.mustache
        * убираем пространство имен thymeleaf-а
        * изменяем шаблон вывода сообщения
    * в контроллере вместо модели теперь используется Map<String, Object>
    * а также добавлен обработчик для главной страницы
    
    
* урок 2. подключение БД
    * устанавливаем postgres (опционально, вместо MySQL из гайда спринга)
        * [Postgre SQL для Windows](https://www.postgresql.org/download/windows/)
        * если при установке не был запрошен пароль, то по [инструкции](https://overcoder.net/q/9607/%D1%8F-%D0%B7%D0%B0%D0%B1%D1%8B%D0%BB-%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9-%D0%B2%D0%B2%D0%B5%D0%BB-%D0%BF%D1%80%D0%B8-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B5-postgres) сбрасываем пароль и устанавливаем новый
        * проверяем подключение к БД например через вкладку Database в Intellij IDEA
        * также доступ к БД можно осуществить через консоль pgAdmin
        * основной синтаксис можно посмотреть например [здесь](https://metanit.com/sql/postgresql/1.1.php)
    * добавляем lombok (опционально)
    * ищем гайд подключения БД на сайте спринга (MySQL)
        * добавляем зависимости JPA и postgresql
        * добавляем properties и прописываем настройки подключения БД
        * добавляем package domain для хранения сущностей БД
            * добавляем в него entity "сообщений"
                * для класса entity нужен конструктор по умолчанию
        * добавляем package repo для доступа к сущностям БД с помощью JPA
            * создаем репозиторий MessageRepository на основе CrudRepository
        * выводим на главную страницу список сообщений
            * добавляем форму на страницу ([manual](http://mustache.github.io/mustache.5.html) по mustache)
            * переписываем меппинг main в контроллере, используя MessageRepository
        * даем пользователям возможность добавлять сообщения в БД
            * рисуем форму ввода для добавления сообщений в БД
            * добавляем обработчик в контроллер (при сохранении в БД используем [redirect](https://www.baeldung.com/spring-redirect-and-forward))
        * фильтры сообщений
            * добавляем форму отбора по тегу
            * навешиваем post обработчик
            * добавляем в MessageRepository поиск сообщений по тегу используя [DSL Spring Data](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)


* урок 3. авторизация, пользователи
    * всё стандартно: ищем спринговский [гайд](https://spring.io/guides/gs/securing-web/) по security web
    * главной страницей теперь будет greeting
        * меняем меппинги для greeting -> **'/'** и для main -> **'/main'**
        * action-ы для форм
        * и redirect: в контроллере
        * убираем передаваемые параметры (обезличиваем)
        * на странице приветствия располагаем ссылку на главную страницу
    * добавляем зависимость spring-boot-starter-security
    * определяем package config, в котором будут располагаться конфигурационные классы спринга
        * добавляем конфиг для простого меппинга страниц без использования контроллера (реализуя интерфейс WebMvcConfigurer)
        * добавляем конфиг для настройки доступа (реализуем интерфейс WebSecurityConfigurerAdapter)
            * помечается аннотацией EnableWebSecurity для включения интеграции Spring Security и Spring MVC
            * переопределяем configure для детальной настройки доступа
            * и (временно) userDetailsService для проверки входа пользователя (хардкодом добавляем пользователя в список)
    * добавляем страницу логина
    * на главную страницу добавляем кнопку logout
    * из-за того, что используем Mustache, у нас не будет автоматического пробрасывания [CSRF](https://ru.wikipedia.org/wiki/Межсайтовая_подделка_запроса) (как было бы в случае с thymeleaf)
        * csrf 
        * expose-request-attributes = true
        * во все страницы во все формы с "POST" добавляем невидимое поле пробрасывания csrf токена
    * удаляем захардкоженного пользователя и добавляем возможность работать с пользователями в БД
        * сущность User
            * служебная сущность Role (enum)
            * Set ролей для пользователя со связями и ленивой инициализацией
        * удаляем userDetailsService в конфиг классе и вместо него переопределяем configure(AuthenticationManagerBuilder auth)
            * устанавливаем jdbc-аутентификацию
            * datasource для хождения в БД
            * получение полей пользователя
            * получение списка ролей пользователя
        * добавляем страницу регистрации пользователей и ссылку на нее со страницы логина
        * создаем новый контроллер для работы с обработчиками событий пользователей RegistrationController
            * обработчик перехода на страницу регистрации
            * обработчик добавления нового пользователя с проверкой существования и вывода сообщения на странице регистрации, если проверку не прошёл
                * также в WebSecurityConfig добавляем права для всех пользователей на страницу registration
        * все контроллеры выносим в отдельный package
        

* урок 4. связи между таблицами. one-to-many
    * добавляем к сообщению автора (User)
        * настраиваем меппинг:
        * у одного пользователя может быть несколько сообщений: @ManyToOne - со стороны сообщения
        * с помощью параметра аннотации JoinColumn задаем имя колонки user_id
    * добавляем классу User функциональность интерфейса UserDetails (из пакета security). Это вроде как функциональность аккаунта (но это не точно)
        * переопределяем методы заглушками, кроме получения прав. это у нас роли
            * для этого класс Ролей должен иметь функциональность (интерфейс) GrantedAuthority (из пакета security)
    * добавляем package для сервисов
    * добавляем UserService с функциональностью UserDetailsService (из пакета security)
        * в переопределяемом методе возвращается пользователь по имени с помощью JPA-репозитория
    * автовайрим этот сервис в WebSecurityConfig и используем его вместо jdbcAuth и dataSource
        * скорее всего из-за этого пришлось поменять ленивую инициализацию на жадную для списка ролей пользователя
    * в main контроллере при добавлении сообщения автовайрим с помощью AuthenticationPrincipal пользователя и устанавливаем его в качестве автора сообщения
    * на main странице в списке сообщений отображаем кастомное (фишка groovy) поле authorName, которое определилось по методу getAuthorName


* урок 5. подключаем шаблонизатор [Freemarker](https://freemarker.apache.org/docs/dgui.html)
    * старый шаблонизатор перестал устраивать (например сейчас появилась идея выделить в отдельный шаблон повторяющийся код)
    * подготовка
        * меняем зависимости мусташа на фримаркер
        * меняем настройку expose-request-attributes (свойство, отвечающее за помещение _csrf токенов в контекст шаблонизатора) в ямле на фримаркер
    * после этого нужно вынести общую часть страниц в отдельный базовый шаблон, содержащий описание HTML страницы и все импорты
    * создаем директорию parts и в ней файл common.ftl
        * тег </#macro> отвечает за макрос (вынесенный в отдельный файл блок кода для переиспользования)
        * <#nested> - вложенный код. а точнее - место, куда будет вложен код
    * далее поочередно проходим по всем шаблонам и выносим общий код в шаблоны-макросы
        * импортируем макрос с помощью секции import в начале файла
        * весь лишний код - включая теги html, заголовки и body - удаляем
        * заворачиваем наш код, который должен быть внутри шаблона, в теги <@c.page> (@ + алиас + . + имя макроса)
    * для форм логина и регистрации логика будет немного другая. для этих форм есть общая часть, в которой меняется одна из переменных
        * для этого при объявлении макроса после имени надо перечислить переменные (<#macro login path>)
        * также _csrf.token будет доступен в контексте, поэтому лишние скобки можно удалить и записать следующим образом: ${_csrf.token}
        * передача параметра осуществляется например так: <@l.login "/registration" />
    * следующим этапом переименовываем оставшиеся шаблоны и немного меняем разметку для использования команд Freemarker вместо отключенного Mustache
    * также пофиксили еще момент: когда осуществляем поиск с главной страницы, то остаемся на той же странице, но адрес меняется на /filter
    * [Страница с описанием директивы list:](https://freemarker.apache.org/docs/ref_directive_list.html)
    * [Страница с инструкцией по описанию собственных директив:](https://freemarker.apache.org/docs/dgui_misc_userdefdir.html)
    * [Страница с объяснением по импортам и пространствам имен:](https://freemarker.apache.org/docs/dgui_misc_namespace.html)
    