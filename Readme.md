
Приложение Sweater - Аналог твиттера
***

[канал let's code](https://www.youtube.com/channel/UC1g3kT0ZcSXt4_ZyJOshKJQ)
***

#### Этапы

* подготовка
    * идем на spring.io
    * в гайдах ищем MVC
    * создаём проект maven
    
          
* урок 1 (Hello, World)
    * pom.xml
        * указываем используемую версию java
        * секцию **parent** для spring boot
        * зависимости:
            * thymeleaf (шаблонизатор)
            * starter-web
            * dev-tools (для удобного перезапуска приложения)
            * тестирование
        * а также плагин для сборки
    * добавляем GreetingController
    * а также класс запуска приложения ServingWebContentApplication
    * и страницу greeting.html, которая просто отображает имя, переданное через get-параметр name


* урок 1 (Hello, World). часть 2. замена thymeleaf на mustache (шаблонизатор попроще)
    * изменяем dependency
    * greeting.html на greeting.mustache
        * убираем пространство имен thymeleaf-а
        * изменяем шаблон вывода сообщения
    * в контроллере вместо модели теперь используется Map<String, Object>
    * а также добавлен обработчик для главной страницы
    
    
* урок 2. подключение БД
    * устанавливаем postgres (опционально, вместо MySQL из гайда спринга)
        * [Postgre SQL для Windows](https://www.postgresql.org/download/windows/)
        * если при установке не был запрошен пароль, то по [инструкции](https://overcoder.net/q/9607/%D1%8F-%D0%B7%D0%B0%D0%B1%D1%8B%D0%BB-%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9-%D0%B2%D0%B2%D0%B5%D0%BB-%D0%BF%D1%80%D0%B8-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B5-postgres) сбрасываем пароль и устанавливаем новый
        * проверяем подключение к БД например через вкладку Database в Intellij IDEA
        * также доступ к БД можно осуществить через консоль pgAdmin
        * основной синтаксис можно посмотреть например [здесь](https://metanit.com/sql/postgresql/1.1.php)
    * добавляем lombok (опционально)
    * ищем гайд подключения БД на сайте спринга (MySQL)
        * добавляем зависимости JPA и postgresql
        * добавляем properties и прописываем настройки подключения БД
        * добавляем package domain для хранения сущностей БД
            * добавляем в него entity "сообщений"
                * для класса entity нужен конструктор по умолчанию
        * добавляем package repo для доступа к сущностям БД с помощью JPA
            * создаем репозиторий MessageRepository на основе CrudRepository
        * выводим на главную страницу список сообщений
            * добавляем форму на страницу ([manual](http://mustache.github.io/mustache.5.html) по mustache)
            * переписываем меппинг main в контроллере, используя MessageRepository
        * даем пользователям возможность добавлять сообщения в БД
            * рисуем форму ввода для добавления сообщений в БД
            * добавляем обработчик в контроллер (при сохранении в БД используем [redirect](https://www.baeldung.com/spring-redirect-and-forward))
        * фильтры сообщений
            * добавляем форму отбора по тегу
            * навешиваем post обработчик
            * добавляем в MessageRepository поиск сообщений по тегу используя [DSL Spring Data](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)


* урок 3. авторизация, пользователи
    * всё стандартно: ищем спринговский [гайд](https://spring.io/guides/gs/securing-web/) по security web
    * главной страницей теперь будет greeting
        * меняем меппинги для greeting -> **'/'** и для main -> **'/main'**
        * action-ы для форм
        * и redirect: в контроллере
        * убираем передаваемые параметры (обезличиваем)
        * на странице приветствия располагаем ссылку на главную страницу
    * добавляем зависимость spring-boot-starter-security
    * определяем package config, в котором будут располагаться конфигурационные классы спринга
        * добавляем конфиг для простого меппинга страниц без использования контроллера (реализуя интерфейс WebMvcConfigurer)
        * добавляем конфиг для настройки доступа (реализуем интерфейс WebSecurityConfigurerAdapter)
            * помечается аннотацией EnableWebSecurity для включения интеграции Spring Security и Spring MVC
            * переопределяем configure для детальной настройки доступа
            * и (временно) userDetailsService для проверки входа пользователя (хардкодом добавляем пользователя в список)
    * добавляем страницу логина
    * на главную страницу добавляем кнопку logout
    * из-за того, что используем Mustache, у нас не будет автоматического пробрасывания [CSRF](https://ru.wikipedia.org/wiki/Межсайтовая_подделка_запроса) (как было бы в случае с thymeleaf)
        * csrf 
        * expose-request-attributes = true
        * во все страницы во все формы с "POST" добавляем невидимое поле пробрасывания csrf токена
    * удаляем захардкоженного пользователя и добавляем возможность работать с пользователями в БД
        * сущность User
            * служебная сущность Role (enum)
            * Set ролей для пользователя со связями и ленивой инициализацией
        * удаляем userDetailsService в конфиг классе и вместо него переопределяем configure(AuthenticationManagerBuilder auth)
            * устанавливаем jdbc-аутентификацию
            * datasource для хождения в БД
            * получение полей пользователя
            * получение списка ролей пользователя
        * добавляем страницу регистрации пользователей и ссылку на нее со страницы логина
        * создаем новый контроллер для работы с обработчиками событий пользователей RegistrationController
            * обработчик перехода на страницу регистрации
            * обработчик добавления нового пользователя с проверкой существования и вывода сообщения на странице регистрации, если проверку не прошёл
                * также в WebSecurityConfig добавляем права для всех пользователей на страницу registration
        * все контроллеры выносим в отдельный package
        

* урок 4. связи между таблицами. one-to-many
    * добавляем к сообщению автора (User)
        * настраиваем меппинг:
        * у одного пользователя может быть несколько сообщений: @ManyToOne - со стороны сообщения
        * с помощью параметра аннотации JoinColumn задаем имя колонки user_id
    * добавляем классу User функциональность интерфейса UserDetails (из пакета security). Это вроде как функциональность аккаунта (но это не точно)
        * переопределяем методы заглушками, кроме получения прав. это у нас роли
            * для этого класс Ролей должен иметь функциональность (интерфейс) GrantedAuthority (из пакета security)
    * добавляем package для сервисов
    * добавляем UserService с функциональностью UserDetailsService (из пакета security)
        * в переопределяемом методе возвращается пользователь по имени с помощью JPA-репозитория
    * автовайрим этот сервис в WebSecurityConfig и используем его вместо jdbcAuth и dataSource
        * скорее всего из-за этого пришлось поменять ленивую инициализацию на жадную для списка ролей пользователя
    * в main контроллере при добавлении сообщения автовайрим с помощью AuthenticationPrincipal пользователя и устанавливаем его в качестве автора сообщения
    * на main странице в списке сообщений отображаем кастомное (фишка groovy) поле authorName, которое определилось по методу getAuthorName


* урок 5. подключаем шаблонизатор [Freemarker](https://freemarker.apache.org/docs/dgui.html)
    * старый шаблонизатор перестал устраивать (например сейчас появилась идея выделить в отдельный шаблон повторяющийся код)
    * подготовка
        * меняем зависимости мусташа на фримаркер
        * меняем настройку expose-request-attributes (свойство, отвечающее за помещение _csrf токенов в контекст шаблонизатора) в ямле на фримаркер
    * после этого нужно вынести общую часть страниц в отдельный базовый шаблон, содержащий описание HTML страницы и все импорты
    * создаем директорию parts и в ней файл common.ftl
        * тег </#macro> отвечает за макрос (вынесенный в отдельный файл блок кода для переиспользования)
        * <#nested> - вложенный код. а точнее - место, куда будет вложен код
    * далее поочередно проходим по всем шаблонам и выносим общий код в шаблоны-макросы
        * импортируем макрос с помощью секции import в начале файла
        * весь лишний код - включая теги html, заголовки и body - удаляем
        * заворачиваем наш код, который должен быть внутри шаблона, в теги <@c.page> (@ + алиас + . + имя макроса)
    * для форм логина и регистрации логика будет немного другая. для этих форм есть общая часть, в которой меняется одна из переменных
        * для этого при объявлении макроса после имени надо перечислить переменные (<#macro login path>)
        * также _csrf.token будет доступен в контексте, поэтому лишние скобки можно удалить и записать следующим образом: ${_csrf.token}
        * передача параметра осуществляется например так: <@l.login "/registration" />
    * следующим этапом переименовываем оставшиеся шаблоны и немного меняем разметку для использования команд Freemarker вместо отключенного Mustache
    * также пофиксили еще момент: когда осуществляем поиск с главной страницы, то остаемся на той же странице, но адрес меняется на /filter
    * [Страница с описанием директивы list:](https://freemarker.apache.org/docs/ref_directive_list.html)
    * [Страница с инструкцией по описанию собственных директив:](https://freemarker.apache.org/docs/dgui_misc_userdefdir.html)
    * [Страница с объяснением по импортам и пространствам имен:](https://freemarker.apache.org/docs/dgui_misc_namespace.html)
    
* урок 6. добавляем панель администратора и роли пользователей, ограничиваем доступ
    * добавляем новую роль в enum Role - админа - который будет управлять пользователями
    * добавляем контроллер, навешиваем на него реквест меппинг (чтобы не писать для каждого метода одинаковое начало)
    * создаем страницу списка всех пользователей
        * тут есть особенность добавления разделителей для элементов списка
    * выводим на main ссылку на созданную страницу
    * следующим этапом добавляем шаблон для редактирования пользователя, где доступными для редактирования сделаны поля username и roles (доступный в виде списка чекбоксов)
        * и метод в контроллере для неё
        * Spring умеет читать с переданного в пути параметра читать id и подхватывать по нему пользователя
        * в редакторе пользователя для вывода ролей используем функции [seq_contains](https://freemarker.apache.org/docs/ref_builtins_sequence.html#ref_builtin_seq_contains)
    * теперь для любого авторизованного пользователя доступен список всех пользователей и возможность изменения их имени и списка ролей
    * следующим логичным шагом будет ограничение прав
        * добавляем на UserController аннотацию ```@PreAuthorize("hasAuthority('ADMIN')")```
            * она ограничивает доступ к панели администратора и оставит его только для пользователей с ролью ADMIN
            * но эта аннотация не будет работать до добавления конфигурационной аннотации ```@EnableGlobalMethodSecurity(prePostEnabled = true)``` на классе WebSecurityConfig
    * таким образом реализовали базовое ограничение доступа по ролям. и на этом можно строить какую-то иерархию прав
    * доп литература:
        * [Документация](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#el-access) по языку выражений Spring Security, определяющих доступ


* урок 7. загрузка файлов на сервер и раздача статики
    * первым делом в файле application.properties добавляем свойство, в котором будет храниться абсолютный путь в файловой системе, где мы будем сохранять загруженные файлы и откуда мы их будем раздавать
    * в MvcConfig классе необходимо настроить мэппинг для раздачи загруженных файлов
    * после этого добавляем поле загрузки файла в форму ввода сообщения и код, выводящий картинку в список сообщений (при наличии картинки у сообщения)
    * далее перемещаемся в контроллер MainController и добавляем обработку MultipartFile параметра формы. Для исключения коллизий к имени загружаемого файла мы добавляем ключ из UUID
    * также в MvcConfig нам нужно добавить мэпинг для раздачи статического контента из classpath. Отличие мэппингов для статики и загруженных файлов в том, что для статики мы указываем путь, начинающийся с "classpath:", что означает, что поиск файлов будет происходить в директории приложения, а для загруженных файлов путь будет начинаться с "file:" и поиск файлов будет происходить во внешней директории, указанной пользователем
    

* урок 8. оформляем UI c Bootstrap
    * [Сайт](https://getbootstrap.com/) Bootstrap
    * Первым делом перейдем на сайт Bootstrap и откроем [руководство быстрого старта](https://getbootstrap.com/docs/4.1/getting-started/introduction/)
    * Скопируем из него тэги, подключающие стили и скрипты Bootstrap и вставим их в наш главный шаблон common.ftl. После этого обернём директиву #nested этого шаблона в стили контейнера со [страницы руководства](https://getbootstrap.com/docs/4.1/layout/grid/), описывающей систему сеток Bootstrap
    * Следом переделаем наше меню навигации по [странице руководства](https://getbootstrap.com/docs/4.1/components/navbar/), описывающей примеры оформления навигационных панелей
    * Для управления отображением элементов меню в зависимости от того, залогинен ли пользователь и какие у него права, нам необходимо создать шаблон, не содержащий оформления, но определяющий полезные значения: имя пользователя и признак того, что пользователь имеет админские права. Для этого используем директиву Freemarker [assign](https://freemarker.apache.org/docs/ref_directive_assign.html)
    * Для включения этого шаблона в панель навигации используем директиву [include](https://freemarker.apache.org/docs/ref_directive_include.html)
    * При компоновке объектов на странице часто возникает необходимость добавить отступ между элементами. Для этого в Bootstrap присутствует [набор стилей с отступами](https://getbootstrap.com/docs/4.0/utilities/spacing/)
    * Далее мы перерабатываем форму логина с использованием стилей из [руководства по оформлению форм](https://getbootstrap.com/docs/4.1/components/forms/)
    * Переходим к странице добавления и просмотра сообщений, где меняем оформление формы ввода нового сообщения, сделав форму ввода "схлопываемой" по примеру из [документации](https://getbootstrap.com/docs/4.1/components/collapse/)
    * И последним штрихом меняем оформление сообщений в виде [карточек, сверстанных в 3 колонки](https://getbootstrap.com/docs/4.1/components/card/)
    
    
* урок 9. Spring Boot Mail: рассылка почты пользователям, активация аккаунта
    * Добавляем оповещения пользователей по электронной почте, добавляем механизм проверки почтового ящика пользователя (активация аккаунта)
    * Первым делом добавим зависимость на Spring Mail
    * Для оповещения пользователя по почте прежде всего нужно куда-то сохранить его адрес. Добавим в доменный объект User поля email и activationCode. После чего на форме регистрации выведем поле ввода почтового адреса. Следующим шагом модифицируем код контроллера регистрации и сервиса работы с пользователями, для сохранения информации о почте и добавим уникальный код активации для подтверждения того, что пользователь ввёл адрес ящика, к которому действительно у него есть доступ.
      После этого создадим сервис MailSender, который будет осуществлять рассылку почты. Также нам потребуется создать конфигурационный класс MailConfig, в котором мы будем содавать инстанс класса JavaMailSenderImpl, осуществляющего низкоуровневые оперции с сервером почты. Для этого класса введем в файл application.properties некоторые параметры
    * [Настройки доступа](https://yandex.ru/support/mail/mail-clients.html#imap) к почтовому серверу Яндекса
    * После этого добавим в UserService код рассылки почтовых уведомлений о необходимости регистрации и добавим в RegistrationController код, принимающий запрос активации от пользователя. Данный код будет проверять наличие пользователя в БД, имеющего такой код активации, после чего код будет удалён из БД    
    * Для проверки корректности работы приложения можно использовать [сервис временных почтовых ящиков](https://temp-mail.org/ru/view/a0a6cfdb82ac42e62d87ec27e1d1b159/)

        
* урок 10. Spring Boot Flyway: миграции БД, профиль пользователя
    * Готовим приложение к деплою, наводим порядок: фиксируем структуру БД и переходим на версионирование БД с использованием flyway.
    * Дополнительно добавляем в БД дефолтного администратора и добавляем страницу профиля пользователя, где каждый пользователь может поменять свой пароль или email.
    * Миграции нужны для версионирования изменений БД в соответствии со структурой доменной модели. Проще говоря: при запуске проекта из репозитория с нуля на любом этапе, мы получим нужную структуру БД, со всеми таблицами и полями, которые нужны для работы приложения + все необходимые данные, вроде дефолтного администратора.
    * [Сайт](https://flywaydb.org/) flyway
    * Самой первой миграцией нужно задать стартовую структуру БД. Для этого добавим в наш файл application.properties необходимые свойства.
    * И запустим приложение. В логах приложения ищем записи, начинающиеся со слова Hibernate и копируем все строки, в которых создаются объекты БД. После этого создаём директорию миграций db/migration в директории проекта resources, куда добавляем первый файл миграции с именем V1__Init_db.sql. Правила оформления имен файлов можно почитать [тут](https://flywaydb.org/documentation/migrations#naming)
    * В этот файл вставляем скопированные из логов скрипты и оформляем код, в соответствии с требованиями синтаксиса SQL. Осталось добавить зависимость на flyway и переход на миграции окончен.
    * Теперь при разворачивании приложения на сервере мы получим чистую БД. Соответственно, все новые пользователи будут иметь рядовые права и создать администратора будет невозможно без прямого доступа к БД.
    * Чтобы исправить этот огрех, добавим миграцию, в которой вручную опишем добавление администратора по умолчанию. Создаём скрипт миграции V2__Add_admin.sql и описываем там добавление пользователя.
    * Теперь администратор есть, но у него фиксированный и простой пароль, который он (да и любой другой пользователь) не может изменить. Также никто из пользователей не может изменить свой email.
    * Для добавления редактора этих полей, создаём шаблон profile.ftl и ответную его часть в контроллере UserController. В UserService добавляем код, обрабатывающий смену пароля и почтового адреса. Если происходит смена почты, то повторно отправляем пользователю ссылку на подтверждение почтового адреса.
    * Для проверки корректности работы приложения можно использовать [сервис временных почтовых ящиков](https://temp-mail.org/ru/view/a0a6cfdb82ac42e62d87ec27e1d1b159/)    
    

* урок 11. Spring Boot: bean vaildation, шифрование паролей
    * Готовим приложение к деплою, наводим порядок: добавляем шифрование паролей и проверку (валидацию) данных, приходящих на сервер.
    * Первым шагом добавим шифрование паролей: в классе WebSecurityConfig добавим инициацию бина PasswordEncoder классом BCryptPasswordEncoder. И сразу же подставим его в authenticationBuilder. Далее добавим шифрование пароля нового пользователя при его регистрации в UserService.
    * Чтобы уже зарегистрированные в системе пользователи могли войти в систему, добавим скрипт миграции, шифрующий уже унесенные пароли.
    * Следующим шагом добавим валидацию входящих данных с помощью механизма Bean Validation. Для этого на поля доменных классов добавим аннотации @Length, @NotBlank и пр. с указанием ограничений и сообщений, которые будут отображаться при ошибках валидации.
    * После этого немного модифицируем контроллеры: добавим к получаемым от пользователя данным аннотацию @Valid и 2 обязательных аргумента: BindingResult и Model, которые должны идти в порядке, приведенном в данном тексте. Первый из них принимает сообщения валидации, а второй служит для передачи данных из контроллера во view.      
    * Последним шагом остаётся только вывести сообщения об ошибках валидации во view. Для оформления сообщений используем стили из CSS фреймворка Bootstrap.
    

* урок 12. Spring Boot: reCaptcha, restClient, rememberMe и сохранение сессий
    * Добавляем reCaptcha, поддержку rememberMe и хранения сессий в БД. Spring Boot упакован многими удобными механизмами, но поддержки капчи “из коробки” не сделано, что мы и исправим.
    * Для примера мы возьмём проект reCaptcha, т.к. он достаточно быстрый, надёжный и легко встраивается в любой проект.
    * Первым делом нужно зарегистрировать аккаунт в проекте recaptcha и получить все необходимые ключи. Сайты проекта reCaptcha: [[1]](https://www.google.com/recaptcha/admin/create#list) и [[2]](https://developers.google.com/recaptcha/docs/verify)
    * Добавляем зависимости и настраиваем Spring Session и reCaptcha
    * Для проверки корректности пользовательского ввода нам необходимо делать rest запросы к серверу recaptcha. Для этого мы используем встроенный в Spring Boot rest клиент, кратко описанный в [следующем гайде](https://spring.io/guides/gs/consuming-rest/)
    * Для поддержки rememberMe достаточно в настройках Spring Security добавить вызов одного метода, имеющего то же самое имя: rememberMe. После чего пользователь будет автоматически авторизовываться в нашем приложении, даже если у него истекло время действия сессии на web сервере.
    * Но если у нас имеется несколько серверов и после технических манипуляций, вызывающих перезагрузку сервера, у нас будет пропадать информация, необходимая для автоматической авторизации пользователя. Поэтому мы добавим в наше приложение поддержку Spring Session JDBC, что позволит хранить активные сессии пользовтелей в БД.
    * [Spring session JDBC](https://docs.spring.io/spring-session/docs/current/reference/html5/guides/boot-jdbc.html)
    
    
* уроки 13-14. Spring Boot: публикуем приложение на сервер (deploy), Linux, Windows
    * [Установка SDKman](https://www.youtube.com/watch?v=YCNiWmbnEQ8)
    * [Основы работы в Vi (Vim](https://www.youtube.com/watch?v=6H0GDM8ExB8)
    * Чаще всего приложения на java разворачивают на серверах linux, поэтому рассматривается деплой с использованием инструментария *nix систем. Понадобятся ssh и bash. Перед началом работы необходимо сгенерировать ssh ключи (ssh-keygen) и зарегистрировать их на сервере, где будет запускаться сервер приложения.
    * Если используем linux, freebsd или macos, то у нас уже полностью готовая среда. В windows можно использовать git for Windows, который включает в поставку все необходимые утилиты. Как установить git for Windows можно посмотреть в [этом](https://www.youtube.com/watch?v=qt-QDN3MyeM) видео:
    * Прежде чем развернуть приложение на сервере, нам необходимо подготовиться: добавить зависимости JAXB и вынести инициализацию PasswordEncoder в отдельный класс.
    * Следующим шагом сделаем 2 файла с настройками: для девелоперской среды (application-dev.properties) и для запуска на “боевых” серверах (application.properties). Для выбора файла конфигурации добавим параметр запуска приложения в режиме разработки: 
    ```--spring.profiles.active=dev```
    * После этого добавим скрипт деплоя, установим ему право на выполнение командой ```chmod +x scripts/deploy.sh``` и запустим его
    * Перед запуском приложения необходимо убедиться, что на сервере установлены postgres (и создана БД sweater) и nginx (и он настроен), который мы будем использовать как прокси.
    
    
* урок 15. Spring Boot: JPA OneToMany - сообщения пользователя, редактор сообщений
    * Добавляем связь oneToMany между пользователем и его сообщениями. Делаем страницу сообщений пользователя и кнопку редактирования сообщений.
    * [Страница документации Bootstrap с дизайном кнопок](https://getbootstrap.com/docs/4.1/components/buttons/)
    
    
* урок 16. Spring Boot: JPA ManyToMany - подписки и подписчики
    * Добавляем связь manyToMany между пользователями, что позволит нам сформировать связи "канал-подписчик".
    * Для добавления возможности подписываться на каналы мы должны добавить 2 поля в класс User: subscriptions и subscribers. Оба эти поля должны содержать Set пользователей и аннотированы @ManyToMany ссылающейся на одну и ту же таблицу user_subscriptions, но с противоположными значениями в аттибутах join_column и inverse_join_column.
    * Также нам нужно добавить миграцию, создащую таблицу для хранения связи многие-ко-многим. 
    * После этого можно приступать к отображению количества подписок и подписчиков на странице пользователя и добавлению кнопок "подписаться/отписаться", а также страницы, отображающей списки подписок и подписчиков.
    * Для оформления используем стили bootstrap:
        * [кнопки "подписаться"]()https://getbootstrap.com/docs/4.1/components/buttons/
        * [список пользователей](https://getbootstrap.com/docs/4.1/components/list-group/)
        * [отображение количества подписок](https://getbootstrap.com/docs/4.1/components/card/)
        * [отступы](https://getbootstrap.com/docs/4.1/utilities/spacing/)


* урок 17. Spring Boot: интеграционное тестирование с Spring Testing
    * Для проверки корректной работы приложения используют различные тесты, наиболее распространённые и лёгкие в написании - интеграционные тесты, позволяющие проверить корректную работу всех механизмов, входящих в приложение, вместе.
    * Для написания наших интеграционных тестов приложения мы будем использвать богатый инструментарий фреймворка Spring Boot.
    * В ходе данного видео мы рассмотрим тестирование авторизации в приложении, получение html страницы нашего приложения (с проверкой корректности отдаваемого результата), отправка get, post и multipart запросов с проверкой корректности ответа сервера.
    * В качестве ориентира возьмём [официальный гайд](https://spring.io/guides/gs/testing-web/) спринга по тестированию вэб слоя
    * К сожалению, официальный гайд  не всеобъемлющ и нам потребуются дополнительные зависимости
    * Для более подробного знакомства с возможностями Spring, позволяющими тестировать приложения, рекомендуется ознакомиться с [официальной документацией](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html)


* урок 18. Spring Boot: постраничное отображение длинных списков (pagination)
    * Зачастую, при построении сайтов и вэб приложений нет неоходимости отображать списки элементов целиком, тем более, что список может быть очень длинным, что негативно скажется работе браузера и сервера. В такой ситуации используется постраничный вывод данных (пагинация, pagination). В Spring MVC для этого также существует решение, которое достаточно просто внедрить в любой существующий вывод списка данных из репозитория.
    * Для начала адаптируем наши репозиторий и контроллер для получения от клиента дополнительных аргументов в строке URL согласно официальной документации
        * [Spring документация по pagination](https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html#d0e785)
    * После чего добавим на страницу вывод ссылок на все доступные страницы и оформим всё это в общей для нашего приложения стилистике
    * [Документация Bootstrap раздел pagination](https://getbootstrap.com/docs/4.1/components/pagination/)
    * [Видео про оформление интерфейса с Bootstrap](https://www.youtube.com/watch?v=a51jGwoTNmI)
    * Часто возникает ситуация, когда при разбиении контента на страницы, мы получаем большое количество страниц и ссылки на эти страницы также требуют много места. В такой ситуации стоит сократить вывод ссылок в пагинаторе.
    * [Диапазоны в Freemarker](https://freemarker.apache.org/docs/dgui_template_exp.html#dgui_template_exp_direct_ranges)
    * [Тeрнарный оператор в Freemarker](https://freemarker.apache.org/docs/ref_builtins_boolean.html#ref_builtin_then)
    * [Конкатенация массивов в Freemarker](https://freemarker.apache.org/docs/dgui_template_exp.html#dgui_template_exp_sequenceop_cat)
    

* урок 19. Spring Boot: модульное тестирование и подмена (mock object)
    * Добавляем модульное (unit) тестирование с помощью JUnit, Mockito и Hamcrest.
    * Модульное тестирование помогает обеспечивать и контролировать работоспособность кода приложения в процессе модификации логики программистами. Зачастую, мы не можем предвидеть все изменения, которые могут произойти в приложении вследствие наших изменений. Поэтому модульное тестирование стоит воспринимать как своеобразный "ремень безопасности".
    * [Документация по Spring test framework](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing)
    * [Видео по интеграционным тестам](https://www.youtube.com/watch?v=Lnc3o8cCwZY)
    * [Документация по фреймворку Mockito](https://site.mockito.org/)
    * [Документация по фреймворку Hamcrest](https://code.google.com/archive/p/hamcrest/wikis/Tutorial.wiki)


* урок 20. Spring Boot: добавляем "лайки", используем HQL (JPQL)
    * Добавляем в наше приложение "лайки" (отметки "мне нравится) с использованием Hibernate HQL (JPQL) - язык запросов, оперирующий не таблицами, а доменной моделью приложения, оформленной с использованием JPA
    * Для отображения лайков нам потребуется немного дополнить нашу доменную модель через добавление JPA связи ManyToMany между сущностями Message и User. Также нам потребуется добавить новую SQL миграцию Flyway, в которой мы опишем создание данной связи. После этого необходимо доработать шаблоны Freemarker для отображения иконки "сердечко", взятой из библиотеки FontAwesome, и немного доработать оформление Bootstrap компонентов. Для того, чтобы при клике на сердечно ставились или снимались отметки "мне нравится", мы добавим дополнительный эндпойнт (http мэппинг) в наш контроллер сообщений
    * [Документация по Spring Data JPQL](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query)
    * [Документация по Hibernate ORM HQL](https://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html#hql)
    * [Выравнивание блоков в Bootstrap](https://getbootstrap.com/docs/4.1/utilities/flex/#align-self)
    * [Страница проекта Font Awesome](https://fontawesome.com/6?next=%2Fhow-to-use%2Fon-the-web%2Fsetup%2Fgetting-started%3Fusing%3Dweb-fonts-with-css)
    * [Видео Sweater Many2Many](https://www.youtube.com/watch?v=JpF0MwdJzO4)
    * [Видео с разбором проекта Google Guava](https://www.youtube.com/watch?v=yYwDnwcawZ4)


* урок 21. Spring Boot + Turbolinks: ускоряем отображение страниц
    * Ускоряем отображение страниц с помощью Turbolinks. Turbolinks - библиотека из мира Ruby, ускоряющая отрисовку страниц после их загрузки. Ускорение достигается засчет перерисовки только тела документа, без ненужной переинициализации всего DOM дерева страницы, а также засчёт исключения загрузки дополнительных ресурсов и инициализации JavaScript кода. Дополнительно данная библиотека добавляет прогресс бар в верхней части страницы, аналогичный тому, что мы можем наблюдать на страницах многих сайтов, вроде YouTube и GitHub
    * [Страница проекта Turbolinks](https://github.com/turbolinks/turbolinks)
    * [Собранный и минифицированный скрипт на CDN](https://cdnjs.com/libraries/turbolinks)
    * [Описание HTML аттрибута defer](http://htmlbook.ru/html/script/defer)
    * [Создание Spring Boot Rest Web приложения](https://www.youtube.com/watch?v=LOmcsf5IylI&list=PLU2ftbIeotGqSTOVNjT4L3Yfy8jatCdhm)
    * [Инструменты разработчика в современных браузерах](https://www.youtube.com/watch?v=8ZKgsdxSdTc)